import torch

import torchtrain as tt


class Base:
    """Common base class for all `torchtrain` objects.

    Defines default `__str__` and `__repr__`.
    Most objects should customize `__str__` according to specific
    needs.

    Custom objects usually use `yaml.dump` to easily see parameters
    and whole pipeline.

    """

    def __str__(self) -> str:
        return f"{type(self).__module__}.{type(self).__name__}"

    def __repr__(self) -> str:
        parameters = ", ".join(
            "{}={}".format(key, value)
            for key, value in self.__dict__.items()
            if not key.startswith("_")
        )
        return "{}({})".format(self, parameters)


###############################################################################
#
#                                   PIPES
#
###############################################################################


class _Stateful(Base):
    """Pipe-like component keeping other pipes as internal state.

    Acts as a base for `accumulators` and `producers` (`iterations`, `steps` and a-like).

    After using `__gt__` \ `__lt__` same object is returned with right hand side
    added as a sink for values.

    """

    def __init__(self):
        self._previous = []
        self._next = []

    def _apply(self, data, pipes):
        return functools.reduce(
            lambda previous_result, pipe: pipe(previous_result), pipes, data,
        )

    def __gt__(self, other):
        if not isinstance(other, (_Stateful, _Statless)):
            raise ValueError(
                "Only `torchtrain._Stateful` or `torchtrain.Stateless` objects can be used with >."
                "Those objects are `torchtrain.Operation`, `torchtrain.iterations.IterationBase`, "
                "`torchtrain.Accumulator`, `torchtrain.steps.StepBase`, `torchtrain.epochs.EpochBase` "
                "or other inheriting from them. Did you mean to inherit from `torchtrain.Operation`?"
            )
        self._next.append(other)
        return self

    def __lt__(self, other):
        if not isinstance(other, (_Stateful, _Statless)):
            raise ValueError(
                "Only `torchtrain._Stateful` or `torchtrain.Stateless` objects can be used with >."
                "Those objects are `torchtrain.Operation`, `torchtrain.iterations.IterationBase`, "
                "`torchtrain.Accumulator`, `torchtrain.steps.StepBase`, `torchtrain.epochs.EpochBase` "
                "or other inheriting from them. Did you mean to inherit from `torchtrain.Operation`?"
            )
        self._previous.append(other)
        return self

    @abc.abstractmethod
    def clear(self):
        pass

    @abc.abstractmethod
    def __call__(self, data):
        pass

    @abc.abstractmethod
    def forward(self, data):
        pass

    def __str__(self):
        return yaml.dump({super().__str__(): {"in": self._previous, "out": self._next}})


class _Stateless(Base):
    """Base class for pipe-like components which DOES NOT keep pipes as `list`.

    Each time ">" or "<" is used it creates new object "StatelessPipe"
    which forwards data appropriately.

    If "_Stateful" is encountered it is added to "_Stateful" object and "_Stateful"
    is returned.

    It is lower in hierarchu than `_Stateful`.

    """

    def __gt__(self, other):
        """Pipe output of this operation into `other`.

        Parameters
        ----------
        other : _Stateless | _Stateful
            Operation working on output generated by `self`
        """
        if isinstance(other, _Stateful):
            return other < self
        if isinstance(other, _Stateless):
            return StatelessPipe(self, other)
        raise ValueError(
            "Only `torchtrain._Stateful` or `torchtrain.Stateless` objects can be used with >."
            "Those objects are `torchtrain.Operation`, `torchtrain.iterations.IterationBase`, "
            "`torchtrain.Accumulator`, `torchtrain.steps.StepBase`, `torchtrain.epochs.EpochBase` "
            "or other inheriting from them. Did you mean to inherit from `torchtrain.Operation`?"
        )

    def __lt__(self, other):
        """Pipe output of this operation into `other`.

        Parameters
        ----------
        other : _Stateless | _Stateful
            Operation working on output generated by `self`
        """

        if isinstance(other, _Stateful):
            return other > self
        if isinstance(other, _Stateless):
            return StatelessPipe(other, self)
        raise ValueError(
            "Only `torchtrain._Stateful` or `torchtrain.Stateless` objects can be used with >."
            "Those objects are `torchtrain.Operation`, `torchtrain.iterations.IterationBase`, "
            "`torchtrain.Accumulator`, `torchtrain.steps.StepBase`, `torchtrain.epochs.EpochBase` "
            "or other inheriting from them. Did you mean to inherit from `torchtrain.Operation`?"
        )


class StatelessPipe(_Stateless):
    """Pipe-like component forwarding data to the next element."""

    def __init__(self, first, second):
        self.first = first
        self.second = second

    def __str__(self) -> str:
        # Special handling of Ifs (for now, find a better way)
        if str(self.second) == "":
            return str(self.first)
        if str(self.first) == "":
            return str(self.second)
        return yaml.dump({str(self.first): str(self.second)})

    def __call__(self, data):
        return self.forward(data)

    def forward(self, data):
        return self.second(self.first(data))


###############################################################################
#
#                                     OP
#
###############################################################################


class Operation(_Stateless):
    """Base class for operations.

    Usually processes data returned / yielded by
    `torchtrain.steps.Step` / `torchtrain.iterations.Iteration` instances.

    Can also be used with `accumulators`, in this case those ops are used BEFORE
    data is passed to `accumulator`.

    Users should implement `forward` method which returns desired value
    after transformation.

    `__call__` does nothing, but is kept for API clarity.

    """

    def __call__(self, data) -> typing.Any:
        return self.forward(data)

    @abc.abstractmethod
    def forward(self, data) -> typing.Any:
        pass


###############################################################################
#
#                               ACCUMULATOR
#
###############################################################################


class Accumulator(_Stateful):
    """Save values for further reuse.

    Values can be saved after each step or iteration.
    If any pipe is applied with `__gt__`, values will be first transformed
    by those pipes and saved as a last step.

    Users should implement `forward` method which returns value(s) which
    are saved after each step. As those values are only references,
    it is a low-cost operation.

    Users should also use `self.data` field in order to accumulate results
    somehow. See `torchtrain.accumulators` for examples.

    """

    def __init__(self):
        super().__init__()
        self.data = None

    def feed(self, data):
        """Run operations added AFTER accumulator.

        Used by `iterations` in order not to run `tensorboard` etc.
        at each value.

        """
        return self._apply(data, self._next)

    def __call__(self, data):
        previous = self._apply(data, self._previous)
        return self.forward(previous)

    @abc.abstractmethod
    def forward(self, data) -> None:
        pass

    @abc.abstractmethod
    def calculate(self) -> typing.Any:
        pass

    @abc.abstractmethod
    def clear(self):
        pass


###############################################################################
#
#                                   PRODUCERS
#
###############################################################################


class _Producer(_Stateful):
    """Produce values and process/save them."""

    # Producer can only forward values. It cannot get modified values
    def __init__(self):
        self._next = []

    def clear(self):
        for pipe in self._next:
            if isinstance(pipe, Accumulator):
                pipe.clear()

    def feed(self, data):
        for pipe in self._next:
            if isinstance(pipe, Accumulator):
                pipe.calculate(data)

    def __lt__(self, _):
        raise ValueError("Producers do not support < as they produce values.")

    @abc.abstractmethod
    def __call__(self, *args, **kwargs):
        pass

    @abc.abstractmethod
    def forward(self, *args, **kwargs):
        pass


class ReturnProducer(_Producer):
    """Producer returning values via `return` statement.

    Differentiation is needed for smooth user experience
    no matter generators (`iterations` or `epochs`) or simple returns
    (usually `step`).

    Applies pipes added via ">" and return UNMODIFIED data.

    """

    def __call__(self, *args, **kwargs):
        data = self.forward(*args, **kwargs)
        self._apply(data, self._next)
        return data

    @abc.abstractmethod
    def forward(self, *args, **kwargs):
        pass


class GeneratorProducer(_Producer):
    """Producer yielding values via `yield` statement.

    Differentiation is needed for smooth user experience
    no matter generators (`iterations` or `epochs`) or simple returns
    (usually `step`).

    Applies pipes added via ">" and yields UNMODIFIED data at each step.

    """

    def __call__(self, *args, **kwargs):
        for data in self.forward(*args, **kwargs):
            self._apply(data, self._next)
            yield data

    @abc.abstractmethod
    def forward(self, *args, **kwargs):
        pass


class Epoch(GeneratorProducer):
    """Base class for epoch-like structures.

    Works like GeneratorProducer, but handles exceptions.EpochsException
    in case earlier exit is required.

    Applies pipes added via ">" and yields UNMODIFIED data at each step.

    """

    def __call__(self, *args, **kwargs):
        with self:
            yield from super().__call__(*args, **kwargs)

    def __enter__(self):
        return self

    def __exit__(self, _, exc_val, __):
        if isinstance(exc_val, exceptions.EpochsException):
            return True
        return False

    @abc.abstractmethod
    def forward(self, *args, **kwargs):
        pass


class Iteration(GeneratorProducer):
    """Base class for iteration-like structures.

    Works like GeneratorProducer, but handles exceptions.IterationsException
    in case earlier exit is required from `iteration`.

    Applies pipes added via ">" and yields UNMODIFIED data at each step.

    """

    def __call__(self, *args, **kwargs):
        with self:
            yield from super().__call__(*args, **kwargs)

    def __enter__(self):
        return self

    def __exit__(self, _, exc_val, __):
        if isinstance(exc_val, exceptions.IterationsException):
            return True
        return False

    @abc.abstractmethod
    def forward(self, *args, **kwargs):
        pass


class Step(ReturnProducer):
    """Base class for step-like structures.

    Works like ReturnProducer, is here to provide unified API across
    `steps`, `iterations` and `epochs`.
    """

    @abc.abstractmethod
    def forward(self, *args, **kwargs):
        pass
